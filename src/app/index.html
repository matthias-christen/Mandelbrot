<!doctype html>
<html>
	<head>
		<script src="lib/jquery-3.1.1.min.js"></script>

		<script src="compiler/Parser.js"></script>
		<script src="compiler/Complex.js"></script>
		<script src="compiler/Generator.js"></script>
		<script src="compiler/ExpressionOptimizer.js"></script>
		<script src="compiler/CodeGenerator_AVX2.js"></script>
		<script src="compiler/MandelbrotCodeGenerator_AVX2.js"></script>
		<script src="compiler/CodeGenerator_Arithmetic_AVX2.js"></script>
		<script src="compiler/CodeGenerator_RealFunctions_AVX2.js"></script>
		<script src="compiler/CodeGenerator_Functions_AVX2.js"></script>
		<script src="compiler/Graph.js"></script>
		<script src="compiler/GraphColoringGreedy.js"></script>
		<!--<script src="compiler/GraphColoringWelshPowell.js"></script>-->
		<script src="compiler/LiveAnalysis.js"></script>
		<script src="compiler/RegisterAllocator.js"></script>
		<script src="compiler/Assembler_AVX2.js"></script>
		<script src="compiler/MandelbrotAssembler_AVX2.js"></script>

		<script src="gui/smartresize.js"></script>

		<script>
			var architecture = {
				registersCount: 16
			};

			var colorMap = [
				{ at: 0, r: 0x00, g: 0x00, b: 0x00 },
				{ at: 0.1, r: 0x06, g: 0x38, b: 0x7a },
				{ at: 0.5, r: 0xe2, g: 0x66, b: 0xcc },
				{ at: 0.7, r: 0xef, g: 0xee, b: 0x94 },
				{ at: 0.8, r: 0x69, g: 0xef, b: 0xb7 },
				{ at: 0.9, r: 0x72, g: 0xc2, b: 0xff }
			];

			var $canvas = undefined;
			var ctx = undefined;
			var ctxHidden = undefined;

			var g_colors = undefined;

			var defaultXmin = -5;
			var defaultYmin = -3;
			var geometry = {
				xmin: defaultXmin,
				ymin: defaultYmin,
				xcenter: 0,
				ycenter: 0,
				h: 0
			};

			function clamp(x, min, max)
			{
				if (x < min)
					return min;
				if (x > max)
					return max;
				return x;
			}

			function compile(formula, cb)
			{
				var expr = Parser.parse(formula);
				var exprOpt = new ExpressionOptimizer(expr);
				var codeGen = new MandelbrotCodeGenerator(exprOpt.generate());
				codeGen.generate();

				//console.log(codeGen.toString());

				allocateRegisters(
					codeGen.instructions,
					architecture,
					4 /* 4 registers for zRe, zIm, cRe, cIm */
				);

				console.log(codeGen.toString());

				var assembler = new MandelbrotAssembler(codeGen.instructions);
				assembler.run();

				console.log(assembler.code.map(x => ('0' + x.toString(16)).substr(-2)).join(' '));

				app.compileCode(assembler.code, codeGen.constants, cb);
			}

			function createColorMap(maxIter)
			{
				g_colors = [];

				var prevStop = colorMap[0];
				var r = prevStop.r;
				var g = prevStop.g;
				var b = prevStop.b;

				g_colors.push((b << 16) | (g << 8) | r);

				var len = colorMap.length;
				for (var i = 1; i < len; i++)
				{
					var curStop = colorMap[i];
					var num = Math.ceil((curStop.at - prevStop.at) * (maxIter - 1));
					var dr = (curStop.r - prevStop.r) / num;
					var dg = (curStop.g - prevStop.g) / num;
					var db = (curStop.b - prevStop.b) / num;

					for (var j = 0; j < num; j++)
					{
						r += dr;
						g += dg;
						b += db;

						g_colors.push(((b | 0) << 16) | ((g | 0) << 8) | (r | 0));
					}

					prevStop = curStop;
				}

				// color for the Mandelbrot set
				g_colors.push(0);
			}

			function renderResult(x, y, width, height, result, histogram)
			{
				var imgData = ctxHidden.createImageData(width, height);
				var data = imgData.data;
				var idx = 0;

				for (var j = 0; j < height; j++)
				{
					for (var i = 0; i < width; i++)
					{
						var c = g_colors[result.charCodeAt(2 * idx) + 128 * result.charCodeAt(2 * idx + 1)] || 0;

						var k = idx * 4;
						data[k] = c & 0xff;
						data[k + 1] = (c >> 8) & 0xff;
						data[k + 2] = c >> 16;
						data[k + 3] = 255;

						++idx;
					}
				}
				
				ctxHidden.putImageData(imgData, x, y);
				ctx.drawImage(ctxHidden.canvas, 0, 0);
			}

			/**
			 * Compute a rectangle of the Mandelbrot set in parallel.
			 */
			function compute(xmin, ymin, x, y, w, h, radius, maxIter, concurrency)
			{
				if (!concurrency)
					concurrency = 1;

				if (!maxIter)
					maxIter = 500;

				if (!g_colors || g_colors.length !== maxIter + 1)
					createColorMap(maxIter);

				// compute the number of chunks and the height of a chunk
				var numChunks = Math.ceil(concurrency * (navigator.hardwareConcurrency || 1));
				var chunkHeight = Math.ceil(h / numChunks);

				// prevent that the chunk height gets too small
				if (chunkHeight < 10)
				{
					chunkHeight = Math.min(h, 10);
					numChunks = Math.ceil(h / chunkHeight);
				}

				var xmaxGlob = xmin + geometry.h * w;
				var ymaxGlob = ymin + geometry.h * h;

				console.log('Computing (' + xmin + ', ' + ymin + ') - (' + xmaxGlob + ', ' + ymaxGlob + ') => (' + x + ', ' + y + ') x (' + w + ', ' + h + ')');

				// start the computations
				for (var i = 0; i < numChunks; i++)
				{
					app.executeCode(
						{
							xmin: xmin,
							ymin: ymin + geometry.h * i * chunkHeight,
							xmax: xmaxGlob,
							ymax: Math.min(ymaxGlob, ymin + geometry.h * (i + 1) * chunkHeight),
							dx: geometry.h,
							dy: geometry.h,
							radius: radius || 2,
							maxIter: maxIter
						},
						renderResult.bind(null, x, y + i * chunkHeight)
					);
				}
			}

			function reset()
			{
				var $view = $('.view');
				var width = $view.width();
				var height = $view.height();

				// set up the default geometry
				geometry.h = Math.max(2 * (geometry.xcenter - defaultXmin) / width, 2 * (geometry.ycenter - defaultYmin) / height);
				geometry.xmin = geometry.xcenter - geometry.h * width * 0.5;
				geometry.ymin = geometry.ycenter - geometry.h * height * 0.5;
			}

			function test()
			{
				var cg = new CodeGenerator();
				var reg1 = cg.createRegister();
				var reg2 = cg.createRegister();
				cg.instructions.push({
					code: 'vmovapd',
					// ops: [ reg1, cg.getConstants(1.0, 10.0, 100.0, 1000.0) ]
					//ops: [ reg1, cg.getConstants(0, -1.0, -123.4, 55.5) ]
					//ops: [ reg1, cg.getConstants(0, 1.0, 10.0, -0.5) ]
					ops: [ reg1, cg.getConstants(0, -1.0, 0.00768, 2.1) ]
				});
				/*
				cg.instructions.push({
					code: 'vmovapd',
					ops: [ reg2, cg.getConstants(-1,  0,      8.9, -0.1) ]
				});*/
				//var ret = cg._real_sincos(reg1);
				//var ret = cg._real_atan2(reg2, reg1);
				//var ret = cg._real_exp(reg1);
				var ret = cg._real_log(reg1);
				/*
				cg.instructions.push({
					code: 'vmovapd',
					ops: [ { type: 'register', id: 0 }, ret.sin ]
				});
				cg.instructions.push({
					code: 'vmovapd',
					ops: [ { type: 'register', id: 1 }, ret.cos ]
				});
				*/
				cg.instructions.push({
					 code: 'vmovapd',
					 ops: [ { type: 'register', id: 0 }, ret ]
				});

				allocateRegisters(
					cg.instructions,
					architecture,
					4 /* 4 registers for zRe, zIm, cRe, cIm */
				);

				console.log(cg.toString());
				console.log('===');
				//console.log(cg.generateDebugCode());

				var asm = new Assembler(cg.instructions);
				asm.run();
				asm.code.push(0xc5, 0xfd, 0x29, 0x06); // vmovapd YMMWORD PTR [rsi],ymm0
				asm.code.push(0xc5, 0xfd, 0x29, 0x4e, 0x20); // vmovapd YMMWORD PTR [rsi+0x20],ymm1
				asm.code.push(0xc3); // ret

				console.log(asm.code.map(x => ('0' + x.toString(16)).substr(-2)).join(' '));

				/*
				for (var i = 0; i < cg.constants.length; i++)
					console.log(JSON.stringify(cg.constants[i]));
				*/

				app.compileCode(asm.code, cg.constants, function()
				{
					app.executeCode({
						xmin: 0,
						ymin: 0,
						xmax: 8,
						ymax: 1,
						dx: 0.5,
						dy: 0.5,
						radius: 0,
						maxIter: 0
					});
				});
			}

			$(document).ready(function()
			{
				var $view = $('.view');
				$canvas = $('#canvas');

				var width = $view.width();
				var height = $view.height();
				var viewOffset = $view.offset();

				ctx = $canvas[0].getContext('2d');
				ctx.canvas.width = width;
				ctx.canvas.height = height;
				ctx.fillStyle = '#000000';

				var canvasHidden = document.createElement('canvas');
				ctxHidden = canvasHidden.getContext('2d');
				ctxHidden.canvas.width = width;
				ctxHidden.canvas.height = height;

				//test();

				// set up the initial geometry
				reset();

				$formula = $('.input-formula');
				$radius = $('.input-radius');
				$maxIter = $('.input-maxiter');

				// recompute the image if the formula has changed
				$formula.change(function()
				{
					try
					{
						compile(
							$formula.val(),
							function()
							{
								reset();
								compute(
									geometry.xmin, geometry.ymin,
									0, 0, ctx.canvas.width, ctx.canvas.height,
									parseFloat($radius.val()),
									parseInt($maxIter.val(), 10)
								);
							}
						);
					}
					catch (e)
					{
						// error message
					}
				});

				$('.btn-compute').click(function()
				{
					compute(
						geometry.xmin, geometry.ymin,
						0, 0, ctx.canvas.width, ctx.canvas.height,
						parseFloat($radius.val()),
						parseInt($maxIter.val(), 10)
					);
				});

				$('.btn-reset').click(function()
				{
					reset();
					compute(
						geometry.xmin, geometry.ymin,
						0, 0, ctx.canvas.width, ctx.canvas.height,
						parseFloat($radius.val()),
						parseInt($maxIter.val(), 10)
					);
				});

				// zoom

				var zoom = {
					tid: null,
					factor: 1
				};

				document.addEventListener('mousewheel', function(event)
				{
					event.preventDefault();

					// get the center point
					var cx = event.clientX - viewOffset.left;
					var cy = event.clientY - viewOffset.top;
					var oldH = geometry.h;

					// compute the zoomed geometry
					var factor = Math.pow(1.01, -event.deltaY);

					geometry.h *= factor;
					geometry.xmin = geometry.xmin + cx * oldH - cx * geometry.h;
					geometry.ymin = geometry.ymin + cy * oldH - cy * geometry.h;

					// compute the overall zoom factor for the pending recompute
					zoom.factor *= factor;

					var w = ctx.canvas.width;
					var h = ctx.canvas.height;

					// scale up/down the image to simulate the zoom (until the next recompute)
					ctx.fillRect(0, 0, w, h);
					ctx.drawImage(
						ctxHidden.canvas,
						cx * (1 - zoom.factor),
						cy * (1 - zoom.factor),
						w * zoom.factor,
						h * zoom.factor,
						0, 0, w, h
					);

					// recompute (debounced)
					if (zoom.tid)
						clearTimeout(zoom.tid);

					zoom.tid = setTimeout(function()
					{
						ctxHidden.drawImage(ctx.canvas, 0, 0);
						compute(
							geometry.xmin, geometry.ymin,
							0, 0, ctx.canvas.width, ctx.canvas.height,
							parseFloat($radius.val()), parseInt($maxIter.val(), 10)
						);

						zoom.factor = 1;
						zoom.tid = null;
					}, 200);
				});

				var move = {
					isMouseDown: false,
					offsetX: 0,
					offsetY: 0,
					startX: 0,
					startY: 0,
					xminOld: 0,
					yminOld: 0,
					tid: null
				};

				document.addEventListener('mousedown', function(event)
				{
					// save the current coordinates in case the image will be moved
					move.isMouseDown = true;
					move.startX = move.offsetX = event.clientX - viewOffset.left;
					move.startY = move.offsetY = event.clientY - viewOffset.top;
					move.xminOld = geometry.xmin;
					move.yminOld = geometry.ymin;
				});

				document.addEventListener('mousemove', function(event)
				{
					// nothing to do if we aren't moving the image
					if (!move.isMouseDown)
						return;

					var x = event.clientX - viewOffset.left;
					var y = event.clientY - viewOffset.top;

					// compute the new (xmin, ymin) coordinates
					geometry.xmin += (move.offsetX - x) * geometry.h;
					geometry.ymin += (move.offsetY - y) * geometry.h;

					// move the portion of the image we already have (no need to recompute)
					ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
					ctx.drawImage(ctxHidden.canvas, x - move.startX, y - move.startY);

					// compute the areas we haven't computed yet (debounced)
					if (move.tid)
						clearTimeout(move.tid);

					move.tid = setTimeout(function()
					{
						var w = ctx.canvas.width;
						var h = ctx.canvas.height;

						var dx = x - move.startX;
						var dy = y - move.startY;

						// copy over the part of the image we already have
						ctxHidden.drawImage(ctx.canvas, 0, 0);

						var radius = parseFloat($radius.val());
						var maxIter = parseInt($maxIter.val(), 10);

						// compute the vertical missing strip
						if (dx !== 0)
						{
							compute(
								dx < 0 ? geometry.xmin + geometry.h * (w + dx) : geometry.xmin,
								dy < 0 ? geometry.ymin : geometry.ymin + geometry.h * dy,
								dx < 0 ? w + dx : 0,
								dy < 0 ? 0 : dy,
								Math.abs(dx),
								h - Math.abs(dy),
								radius, maxIter,
								dy === 0 ? 1 : 0.5
							);
						}

						// compute the horizontal missing strip
						if (dy !== 0)
						{
							compute(
								geometry.xmin,
								dy < 0 ? geometry.ymin + geometry.h * (h + dy) : geometry.ymin,
								0,
								dy < 0 ? h + dy : 0,
								w,
								Math.abs(dy),
								radius, maxIter,
								dx === 0 ? 1 : 0.5
							);
						}

						move.startX = x;
						move.startY = y;
						move.tid = null;
					}, 200);

					move.offsetX = x;
					move.offsetY = y;
				});

				document.addEventListener('mouseup', function(event)
				{
					move.isMouseDown = false;
				});

				$(window).smartresize(function()
				{
					var w = $view.width();
					var h = $view.height();

					ctx.canvas.width = w;
					ctx.canvas.height = h;
					ctxHidden.canvas.width = w;
					ctxHidden.canvas.height = h;

					compute(
						geometry.xmin, geometry.ymin,
						0, 0, w, h,
						parseFloat($radius.val()), parseInt($maxIter.val(), 10)
					);
				});
			});
		</script>

		<link rel="stylesheet" href="gui/css/style.css">
	</head>
	<body>
		<div class="main-bar">
			<input type="text" class="input-formula" placeholder="Formula">
			<button class="btn-compute">Compute</button>
			<button class="btn-reset">Reset</button>
			<input type="text" class="input-radius" placeholder="Escape Radius" value="2">
			<input type="text" class="input-maxiter" placeholder="Maximum Iterations" value="500">
		</div>
		<div class="view">
			<canvas id="canvas"></canvas>
		</div>
	</body>
</html>
