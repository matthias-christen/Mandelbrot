<!doctype html>
<html>
	<head>
		<script src="lib/jquery-3.1.1.min.js"></script>

		<script src="compiler/Parser.js"></script>
		<script src="compiler/Complex.js"></script>
		<script src="compiler/Generator.js"></script>
		<script src="compiler/ExpressionOptimizer.js"></script>
		<script src="compiler/CodeGenerator_AVX2.js"></script>
		<script src="compiler/MandelbrotCodeGenerator_AVX2.js"></script>
		<script src="compiler/CodeGenerator_Arithmetic_AVX2.js"></script>
		<script src="compiler/CodeGenerator_RealFunctions_AVX2.js"></script>
		<script src="compiler/CodeGenerator_Functions_AVX2.js"></script>
		<script src="compiler/Graph.js"></script>
		<script src="compiler/GraphColoringGreedy.js"></script>
		<!--<script src="compiler/GraphColoringWelshPowell.js"></script>-->
		<script src="compiler/LiveAnalysis.js"></script>
		<script src="compiler/RegisterAllocator.js"></script>
		<script src="compiler/Assembler_AVX2.js"></script>
		<script src="compiler/MandelbrotAssembler_AVX2.js"></script>

		<script src="gui/smartresize.js"></script>

		<script>
			var architecture = {
				registersCount: 16
			};

			var $canvas = undefined;
			var ctx = undefined;

			function clamp(x, min, max)
			{
				if (x < min)
					return min;
				if (x > max)
					return max;
				return x;
			}

			function compile(formula, cb)
			{
				var expr = Parser.parse(formula);
				var exprOpt = new ExpressionOptimizer(expr);
				var codeGen = new MandelbrotCodeGenerator(exprOpt.generate());
				codeGen.generate();

				//console.log(codeGen.toString());

				allocateRegisters(
					codeGen.instructions,
					architecture,
					4 /* 4 registers for zRe, zIm, cRe, cIm */
				);

				console.log(codeGen.toString());

				var assembler = new MandelbrotAssembler(codeGen.instructions);
				assembler.run();

				console.log(assembler.code.map(x => ('0' + x.toString(16)).substr(-2)).join(' '));

				app.compileCode(assembler.code, codeGen.constants, cb);
			}

			function compute()
			{
				app.executeCode(
					{
						xmin: -2.1,
						ymin: -1.4,
						xmax: 0.7,
						ymax: 1.4,
						dx: 2.8 / ctx.canvas.width,
						dy: 2.8 / ctx.canvas.height,
						radius: 2,
						maxIter: 500
					},
					function(width, height, result)
					{
						console.log(width + ' x ' + height);

						var imgData = ctx.createImageData(width, height);
						var data = imgData.data;
						var idx = 0;

						for (var j = 0; j < height; j++)
						{
							for (var i = 0; i < width; i++)
							{
								var v = result.charCodeAt(2 * idx) + 128 * result.charCodeAt(2 * idx + 1);
								var g = clamp((v - 256) * 8, 0, 255);
								var k = idx * 4;

								data[k] = g;
								data[k + 1] = g;
								data[k + 2] = clamp(v * 10, 0, 255);
								data[k + 3] = 255;

								++idx;
							}
						}
						
						ctx.putImageData(imgData, 0, 0);
					}
				);
			}

			function test()
			{
				var cg = new CodeGenerator();
				var reg1 = cg.createRegister();
				var reg2 = cg.createRegister();
				cg.instructions.push({
					code: 'vmovapd',
					// ops: [ reg1, cg.getConstants(1.0, 10.0, 100.0, 1000.0) ]
					//ops: [ reg1, cg.getConstants(0, -1.0, -123.4, 55.5) ]
					//ops: [ reg1, cg.getConstants(0, 1.0, 10.0, -0.5) ]
					ops: [ reg1, cg.getConstants(0, -1.0, 0.00768, 2.1) ]
				});
				/*
				cg.instructions.push({
					code: 'vmovapd',
					ops: [ reg2, cg.getConstants(-1,  0,      8.9, -0.1) ]
				});*/
				//var ret = cg._real_sincos(reg1);
				//var ret = cg._real_atan2(reg2, reg1);
				//var ret = cg._real_exp(reg1);
				var ret = cg._real_log(reg1);
				/*
				cg.instructions.push({
					code: 'vmovapd',
					ops: [ { type: 'register', id: 0 }, ret.sin ]
				});
				cg.instructions.push({
					code: 'vmovapd',
					ops: [ { type: 'register', id: 1 }, ret.cos ]
				});
				*/
				cg.instructions.push({
					 code: 'vmovapd',
					 ops: [ { type: 'register', id: 0 }, ret ]
				});

				allocateRegisters(
					cg.instructions,
					architecture,
					4 /* 4 registers for zRe, zIm, cRe, cIm */
				);

				console.log(cg.toString());
				console.log('===');
				//console.log(cg.generateDebugCode());

				var asm = new Assembler(cg.instructions);
				asm.run();
				asm.code.push(0xc5, 0xfd, 0x29, 0x06); // vmovapd YMMWORD PTR [rsi],ymm0
				asm.code.push(0xc5, 0xfd, 0x29, 0x4e, 0x20); // vmovapd YMMWORD PTR [rsi+0x20],ymm1
				asm.code.push(0xc3); // ret

				console.log(asm.code.map(x => ('0' + x.toString(16)).substr(-2)).join(' '));

				/*
				for (var i = 0; i < cg.constants.length; i++)
					console.log(JSON.stringify(cg.constants[i]));
				*/

				app.compileCode(asm.code, cg.constants, function()
				{
					app.executeCode({
						xmin: 0,
						ymin: 0,
						xmax: 8,
						ymax: 1,
						dx: 0.5,
						dy: 0.5,
						radius: 0,
						maxIter: 0
					});
				});
			}

			$(document).ready(function()
			{
				var $view = $('.view');
				$canvas = $('#canvas');

				ctx = $canvas[0].getContext("2d");
				ctx.canvas.width = $view.width();
				ctx.canvas.height = $view.height();

				//test();

				$formula = $('.input-formula');
				$formula.change(function()
				{
					compile($formula.val(), compute);
					/*
					try
					{
						compile($formula.val(), compute);
					}
					catch (e)
					{
						// error message
					}*/
				});

				$('.btn-compute').click(compute);

				$(window).smartresize(function()
				{
					ctx.canvas.width = $view.width();
					ctx.canvas.height = $view.height();
					compute();
				});
			});
		</script>

		<link rel="stylesheet" href="gui/css/style.css">
	</head>
	<body>
		<div class="main-bar">
			<input type="text" class="input-formula" placeholder="Formula">
			<button class="btn-compute">Compute</button>
			<input type="text" class="input-radius" placeholder="Escape Radius">
			<input type="text" class="input-maxiter" placeholder="Maximum Iterations">
		</div>
		<div class="view">
			<canvas id="canvas"></canvas>
		</div>
	</body>
</html>
